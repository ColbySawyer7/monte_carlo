# Rust Native (N-API) Architecture

## Overview

This document explains the architecture for the DES and Monte Carlo simulation engines implemented in Rust and exposed as native Node.js addons via N-API.

## Directory Layout

```
monte_carlo/
├── sim-native/            # Rust workspace (source code)
│   ├── Cargo.toml         # Workspace manifest
│   ├── des/               # DES engine crate
│   ├── monte/             # Monte Carlo engine crate
│   ├── shared/            # Shared utilities
│   └── bench/             # Benchmark binary
│
└── backend/
    └── wasm/              # Native addon bindings and compiled output
        ├── pkg/           # Compiled native addons (generated)
        │   ├── des/       # DES engine .node binary
        │   └── monte/     # Monte Carlo engine .node binary
        └── bindings.js    # Node.js wrapper
```

## Design Decisions

### 1. Separate Rust Workspace (`sim-native/`)

**Why at root level?**
- Keeps Rust tooling separate from Node.js
- Easier to build independently
- Clear separation of concerns
- Can be version controlled separately if needed

**Why workspace structure?**
- `des/` and `monte/` share common types (via `shared/`)
- Monte Carlo depends on DES, so it can import DES as a dependency
- Easier to maintain and test each component independently

### 2. Native Addon Output in `backend/wasm/`

**Why here?**
- Close to where it's used (Node.js backend)
- Easy to import: `require('./wasm/bindings')`
- Matches existing structure (`backend/sim/des/`, `backend/sim/monte/`)

**Structure:**
- `pkg/des/` - DES engine native addon (.node file from napi-rs)
- `pkg/monte/` - Monte Carlo engine native addon (.node file)
- `bindings.js` - Node.js wrapper providing same interface as JS engines

### 3. Multi-Stage Docker Build

**Stage 1: Native Builder**
- Uses `rust:alpine` image
- Installs `@napi-rs/cli`
- Builds both DES and Monte Carlo engines as native addons
- Outputs `.node` files to `backend/wasm/pkg/`

**Stage 2: Node.js Application**
- Uses `node:alpine` image
- Copies compiled native addons from Stage 1
- Native addons are always available, no runtime compilation needed

## Build Process

### Local Development

```bash
# Build native addons
./build-wasm.sh

# Or manually:
cd sim-native/des
napi build --release

cd ../monte
napi build --release
```

### Docker Build

```bash
docker-compose build backend
```

The Dockerfile automatically:
1. Builds native addons in Stage 1
2. Copies to Node.js container in Stage 2
3. Native addons are available at runtime

## Integration with Existing Code

### Migration Strategy

1. **Phase 1**: Keep JS engines, add native addons alongside
2. **Phase 2**: Add feature flag to switch between JS/native
3. **Phase 3**: Default to native, fallback to JS
4. **Phase 4**: Remove JS engines

### Interface Compatibility

The `backend/wasm/bindings.js` provides the same interface:

```javascript
// Original JS interface
const { runSimulation } = require('./sim/des/engine');

// Native addon interface (drop-in replacement)
const { runSimulation } = require('./wasm/bindings');
```

This allows switching engines without changing calling code.

## Performance Benefits

1. **Faster execution**: Native Rust code is typically 10-100x faster than JS
2. **Better memory management**: No garbage collection pauses
3. **Parallel execution**: Full threading support with rayon for Monte Carlo iterations
4. **No conversion overhead**: Direct N-API calls, no JS↔WASM serialization
5. **Native performance**: Compiled machine code, not interpreted

## Development Workflow

### Making Changes

1. Edit Rust code in `sim-native/`
2. Rebuild native addons: `./build-wasm.sh`
3. Restart Node.js server
4. Test changes

### Docker Development

1. Edit Rust code
2. Rebuild: `docker-compose build backend`
3. Restart: `docker-compose restart backend`

### Testing

- Unit tests in Rust: `cargo test` in each crate
- Integration tests: Use existing Node.js test infrastructure
- Performance benchmarks: Compare JS vs native execution times

## File Organization

### Rust Crates

- **`shared/`**: Common types, utilities, serialization
- **`des/`**: DES engine implementation
  - `lib.rs` - Main simulation loop and N-API bindings
  - Contains resource management, distributions, etc.
- **`monte/`**: Monte Carlo aggregator
  - `lib.rs` - Statistics aggregation and N-API bindings
  - Uses rayon for parallel processing

### Native Addon Output

Each `pkg/` directory contains:
- `index.node` - Compiled native binary (N-API addon)
- `index.js` - JavaScript loader wrapper (generated by napi-rs)
- `index.d.ts` - TypeScript definitions
- `package.json` - Module metadata

## Dependencies

### Rust Dependencies

- `napi` + `napi-derive` - N-API bindings for Node.js
- `serde` + `serde_json` - JSON serialization
- `rand` - Random number generation
- `rayon` - Parallel processing for Monte Carlo
- `num_cpus` - CPU core detection

### Build Tools

- `@napi-rs/cli` - Build tool for Rust/N-API native addons
- `cargo` - Rust package manager and build tool

## Future Enhancements

1. **SIMD optimizations**: Vectorized operations for statistics
2. **Streaming results**: Return results incrementally for long simulations
3. **Better error handling**: More detailed error messages and stack traces
4. **Async support**: Use N-API async workers for non-blocking operations

